{"abi":[{"type":"function","name":"balanceOf","inputs":[{"name":"who","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"mint","inputs":[{"name":"to","type":"address","internalType":"address"},{"name":"amount","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"balanceOf(address)":"70a08231","mint(address,uint256)":"40c10f19"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/AdminMinterLeaderboard.sol\":\"IPointsToken\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":@openzeppelin/=node_modules/@openzeppelin/\",\":forge-std/=node_modules/forge-std/src/\"]},\"sources\":{\"contracts/AdminMinterLeaderboard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\ninterface IPointsToken {\\n    function mint(address to, uint256 amount) external;\\n    function balanceOf(address who) external view returns (uint256);\\n}\\n\\ncontract AdminMinterLeaderboard {\\n    IPointsToken public points;\\n    mapping(address => bool) public admins;\\n\\n    uint256 public constant TOPK = 20;\\n\\n    mapping(address => uint256) public lifetime;\\n\\n    struct Entry { address user; uint256 pts; }\\n    Entry[TOPK] private _top;\\n\\n    event AdminUpdated(address indexed admin, bool enabled);\\n    event Awarded(address indexed user, uint256 amount);\\n    event AwardedBatch(uint256 count);\\n    event TopUpdated(address indexed user, uint256 newScore);\\n\\n    modifier onlyAdmin() {\\n        require(admins[msg.sender], \\\"AML:not-admin\\\");\\n        _;\\n    }\\n\\n    constructor(address pointsToken) {\\n        require(pointsToken != address(0), \\\"AML:points-zero\\\");\\n        points = IPointsToken(pointsToken);\\n        admins[msg.sender] = true;\\n        emit AdminUpdated(msg.sender, true);\\n    }\\n\\n    function setAdmin(address user, bool ok) external onlyAdmin {\\n        require(user != address(0), \\\"AML:zero-admin\\\");\\n        admins[user] = ok;\\n        emit AdminUpdated(user, ok);\\n    }\\n\\n    function award(address user, uint256 amount) public onlyAdmin {\\n        require(user != address(0) && amount > 0, \\\"AML:bad-award\\\");\\n        points.mint(user, amount);\\n\\n        uint256 newScore = lifetime[user] + amount;\\n        lifetime[user] = newScore;\\n\\n        _maybeInsertTop(user, newScore);\\n        emit Awarded(user, amount);\\n    }\\n\\n    function awardBatch(address[] calldata users, uint256[] calldata amounts) external onlyAdmin {\\n        uint256 n = users.length;\\n        require(n == amounts.length && n > 0, \\\"AML:bad-arrays\\\");\\n        for (uint256 i = 0; i < n; i++) {\\n            address u = users[i];\\n            uint256 a = amounts[i];\\n            points.mint(u, a);\\n            uint256 newScore = lifetime[u] + a;\\n            lifetime[u] = newScore;\\n            _maybeInsertTop(u, newScore);\\n        }\\n        emit AwardedBatch(n);\\n    }\\n\\n    function getTop() external view returns (Entry[TOPK] memory snapshot) {\\n        return _top;\\n    }\\n\\n    function topAt(uint256 idx) external view returns (address user, uint256 pts) {\\n        require(idx < TOPK, \\\"AML:idx\\\");\\n        Entry memory e = _top[idx];\\n        return (e.user, e.pts);\\n    }\\n\\n    function _maybeInsertTop(address user, uint256 score) internal {\\n        for (uint256 i = 0; i < TOPK; i++) {\\n            if (_top[i].user == user) {\\n                _top[i].pts = score;\\n                _resort();\\n                emit TopUpdated(user, score);\\n                return;\\n            }\\n        }\\n\\n        uint256 idxMin = 0;\\n        uint256 minPts = type(uint256).max;\\n        for (uint256 i = 0; i < TOPK; i++) {\\n            if (_top[i].user == address(0)) {\\n                _top[i] = Entry(user, score);\\n                _resort();\\n                emit TopUpdated(user, score);\\n                return;\\n            }\\n            if (_top[i].pts < minPts) { minPts = _top[i].pts; idxMin = i; }\\n        }\\n\\n        if (score > minPts) {\\n            _top[idxMin] = Entry(user, score);\\n            _resort();\\n            emit TopUpdated(user, score);\\n        }\\n    }\\n\\n    function _resort() internal {\\n        for (uint256 i = 1; i < TOPK; i++) {\\n            Entry memory key = _top[i];\\n            uint256 j = i;\\n            while (j > 0 && _top[j - 1].pts < key.pts) {\\n                _top[j] = _top[j - 1];\\n                j--;\\n            }\\n            _top[j] = key;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x48b29e6ee90ffdd8e7e40d0a915608c53692403e68a824a666ec60bb7c5f8b7f\",\"license\":\"MIT\"}},\"version\":1}","metadata":{"compiler":{"version":"0.8.28+commit.7893614a"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"address","name":"who","type":"address"}],"stateMutability":"view","type":"function","name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"mint"}],"devdoc":{"kind":"dev","methods":{},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"remappings":["@openzeppelin/=node_modules/@openzeppelin/","forge-std/=node_modules/forge-std/src/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":true,"bytecodeHash":"ipfs"},"compilationTarget":{"contracts/AdminMinterLeaderboard.sol":"IPointsToken"},"evmVersion":"paris","libraries":{}},"sources":{"contracts/AdminMinterLeaderboard.sol":{"keccak256":"0x48b29e6ee90ffdd8e7e40d0a915608c53692403e68a824a666ec60bb7c5f8b7f","urls":[],"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ninterface IPointsToken {\n    function mint(address to, uint256 amount) external;\n    function balanceOf(address who) external view returns (uint256);\n}\n\ncontract AdminMinterLeaderboard {\n    IPointsToken public points;\n    mapping(address => bool) public admins;\n\n    uint256 public constant TOPK = 20;\n\n    mapping(address => uint256) public lifetime;\n\n    struct Entry { address user; uint256 pts; }\n    Entry[TOPK] private _top;\n\n    event AdminUpdated(address indexed admin, bool enabled);\n    event Awarded(address indexed user, uint256 amount);\n    event AwardedBatch(uint256 count);\n    event TopUpdated(address indexed user, uint256 newScore);\n\n    modifier onlyAdmin() {\n        require(admins[msg.sender], \"AML:not-admin\");\n        _;\n    }\n\n    constructor(address pointsToken) {\n        require(pointsToken != address(0), \"AML:points-zero\");\n        points = IPointsToken(pointsToken);\n        admins[msg.sender] = true;\n        emit AdminUpdated(msg.sender, true);\n    }\n\n    function setAdmin(address user, bool ok) external onlyAdmin {\n        require(user != address(0), \"AML:zero-admin\");\n        admins[user] = ok;\n        emit AdminUpdated(user, ok);\n    }\n\n    function award(address user, uint256 amount) public onlyAdmin {\n        require(user != address(0) && amount > 0, \"AML:bad-award\");\n        points.mint(user, amount);\n\n        uint256 newScore = lifetime[user] + amount;\n        lifetime[user] = newScore;\n\n        _maybeInsertTop(user, newScore);\n        emit Awarded(user, amount);\n    }\n\n    function awardBatch(address[] calldata users, uint256[] calldata amounts) external onlyAdmin {\n        uint256 n = users.length;\n        require(n == amounts.length && n > 0, \"AML:bad-arrays\");\n        for (uint256 i = 0; i < n; i++) {\n            address u = users[i];\n            uint256 a = amounts[i];\n            points.mint(u, a);\n            uint256 newScore = lifetime[u] + a;\n            lifetime[u] = newScore;\n            _maybeInsertTop(u, newScore);\n        }\n        emit AwardedBatch(n);\n    }\n\n    function getTop() external view returns (Entry[TOPK] memory snapshot) {\n        return _top;\n    }\n\n    function topAt(uint256 idx) external view returns (address user, uint256 pts) {\n        require(idx < TOPK, \"AML:idx\");\n        Entry memory e = _top[idx];\n        return (e.user, e.pts);\n    }\n\n    function _maybeInsertTop(address user, uint256 score) internal {\n        for (uint256 i = 0; i < TOPK; i++) {\n            if (_top[i].user == user) {\n                _top[i].pts = score;\n                _resort();\n                emit TopUpdated(user, score);\n                return;\n            }\n        }\n\n        uint256 idxMin = 0;\n        uint256 minPts = type(uint256).max;\n        for (uint256 i = 0; i < TOPK; i++) {\n            if (_top[i].user == address(0)) {\n                _top[i] = Entry(user, score);\n                _resort();\n                emit TopUpdated(user, score);\n                return;\n            }\n            if (_top[i].pts < minPts) { minPts = _top[i].pts; idxMin = i; }\n        }\n\n        if (score > minPts) {\n            _top[idxMin] = Entry(user, score);\n            _resort();\n            emit TopUpdated(user, score);\n        }\n    }\n\n    function _resort() internal {\n        for (uint256 i = 1; i < TOPK; i++) {\n            Entry memory key = _top[i];\n            uint256 j = i;\n            while (j > 0 && _top[j - 1].pts < key.pts) {\n                _top[j] = _top[j - 1];\n                j--;\n            }\n            _top[j] = key;\n        }\n    }\n}\n","license":"MIT"}},"version":1},"id":0}